ADLB_raw = ADLB_raw
),
modules = root_modules(
# SingleDataViewChooserModule(
#   singleDatasetViewSpec=ADLB_viewspec
# )
# SingleDataViewChooserModule(
#   singleDatasetViewSpec=ADSL_viewspec
# )
# DataViewsChooserModule(
#   datasetViewsSpec=list(ADLB_viewspec, ADSL_viewspec)
# )
DataViewsChooserSummaryModule(
datasetViewsSpec=DatasetViewsSpec(x_view=ADLB_viewspec, y_view=ADSL_viewspec)
)
)
)
ui_DatasetViewsSummaryChooser <- function(id, datasetViewsSpec) {
ns <- NS(id)
standard_layout(
output=plotOutput(ns("plots")),
# tagList(
#   uiOutput(ns("views_summary")),
#   plotOutput(ns("plots"))
# ),
encoding=ui_DatasetViewsChooser(ns("views_chooser"), datasetViewsSpec)
)
}
srv_DatasetViewsSummaryChooser <- function(input, output, session, datasets, datasetViewsSpec) {
summarize_dataviews <- function(dataviews) {
single_dataview <- function(singleDataview) {
keys_list <- paste("Key combinations:", paste(singleDataview$keys_filter$selected, collapse=" OR "))
columns_list <- paste("Selected columns:", paste(singleDataview$columns_filter, collapse=", "))
tagList(
h2(singleDataview$view_name),
tags$ul(tags$li(keys_list), tags$li(columns_list))
)
}
do.call(div,
lapply(dataviews, single_dataview)
)
#paste(lapply(dataviews, single_dataview), collapse="####")
#paste(dataviews, sep="----", collapse="****")
}
dataviews <- callModule(srv_DatasetViewsChooser, "views_chooser", datasets=datasets, datasetViewsSpec=datasetViewsSpec)
output$plots <- renderPlot({
#browser()
plot_view(x_view=dataviews()[["x_view"]], y_view=dataviews()[["y_view"]])
# browser()
# dataviews_evald <- isolate(dataviews())
# plot_view(x_view=dataviews[["x_view"]], y_view=dataviews_evald[["y_view"]])
})
output$views_summary <- renderUI({
summarize_dataviews(dataviews())
})
return(dataviews)
}
DataViewsChooserSummaryModule <- function(
label = "Single Data View Chooser",
datasetViewsSpec=NULL,
pre_output = NULL,
post_output = NULL) {
stopifnot(!is.null(datasetViewsSpec))
#args <- as.list(environment()) #todo: why like this??
# or list(pre_output=pre_output, post_output=post_output, datasetViewsSpec=datasetViewsSpec)
teal::module(
label = label,
server = srv_DatasetViewsSummaryChooser,
ui = ui_DatasetViewsSummaryChooser,
ui_args = list(datasetViewsSpec),
server_args = list(datasetViewsSpec),
filters = NULL
)
}
CDISC_Data <- function(...) {
list(...)
}
DatasetViewsSpec <- function(...) {
args <- list(...)
stopifnot(is_named_list(args))
args
}
library(teal)
x <- teal::init(
data = CDISC_Data(
ASL = ADSL_raw, #todo: adapt so that keys are kept, not used currently
ADLB_raw = ADLB_raw
),
modules = root_modules(
# SingleDataViewChooserModule(
#   singleDatasetViewSpec=ADLB_viewspec
# )
# SingleDataViewChooserModule(
#   singleDatasetViewSpec=ADSL_viewspec
# )
# DataViewsChooserModule(
#   datasetViewsSpec=list(ADLB_viewspec, ADSL_viewspec)
# )
DataViewsChooserSummaryModule(
datasetViewsSpec=DatasetViewsSpec(x_view=ADLB_viewspec, y_view=ADSL_viewspec)
)
)
)
shinyApp(x$ui, x$server)
ui_DatasetViewsSummaryChooser <- function(id, datasetViewsSpec) {
ns <- NS(id)
standard_layout(
output=plotOutput(ns("plots")),
# tagList(
#   uiOutput(ns("views_summary")),
#   plotOutput(ns("plots"))
# ),
encoding=ui_DatasetViewsChooser(ns("views_chooser"), datasetViewsSpec)
)
}
srv_DatasetViewsSummaryChooser <- function(input, output, session, datasets, datasetViewsSpec) {
dataviews <- callModule(srv_DatasetViewsChooser, "views_chooser", datasets=datasets, datasetViewsSpec=datasetViewsSpec)
output$plots <- renderPlot({
#browser()
plot_view(x_view=dataviews()[["x_view"]], y_view=dataviews()[["y_view"]])
# browser()
# dataviews_evald <- isolate(dataviews())
# plot_view(x_view=dataviews[["x_view"]], y_view=dataviews_evald[["y_view"]])
})
output$views_summary <- renderUI({
summarize_dataviews(dataviews())
})
return(dataviews)
}
DataViewsChooserSummaryModule <- function(
label = "Single Data View Chooser",
datasetViewsSpec=NULL,
pre_output = NULL,
post_output = NULL) {
stopifnot(!is.null(datasetViewsSpec))
#args <- as.list(environment()) #todo: why like this??
# or list(pre_output=pre_output, post_output=post_output, datasetViewsSpec=datasetViewsSpec)
teal::module(
label = label,
server = srv_DatasetViewsSummaryChooser,
ui = ui_DatasetViewsSummaryChooser,
ui_args = list(datasetViewsSpec),
server_args = list(datasetViewsSpec),
filters = NULL
)
}
ui_viewsSummary <- function(id) {
ns <- NS(id)
uiOutput(ns("views_summary"))
}
srv_viewsSummary <- function(input, output, session, dataviews_input) {
summarize_dataviews <- function(dataviews) {
single_dataview <- function(singleDataview) {
keys_list <- paste("Key combinations:", paste(singleDataview$keys_filter$selected, collapse=" OR "))
columns_list <- paste("Selected columns:", paste(singleDataview$columns_filter, collapse=", "))
tagList(
h2(singleDataview$view_name),
tags$ul(tags$li(keys_list), tags$li(columns_list))
)
}
do.call(div,
lapply(dataviews, single_dataview)
)
#paste(lapply(dataviews, single_dataview), collapse="####")
#paste(dataviews, sep="----", collapse="****")
}
dataviews_summary <- reactive({
summarize_dataviews(dataviews_input())
})
output$views_summary <- renderUI({
dataviews_summary()
})
dataviews_summary
}
shinyApp(x$ui, x$server)
source('~/choices_selected_dev/plot_xy.R')
DatasetViewsSpec <- function(...) {
args <- list(...)
stopifnot(is_named_list(args))
args
}
library(teal)
x <- teal::init(
data = CDISC_Data(
ASL = ADSL_raw, #todo: adapt so that keys are kept, not used currently
ADLB_raw = ADLB_raw
),
modules = root_modules(
# SingleDataViewChooserModule(
#   singleDatasetViewSpec=ADLB_viewspec
# )
# SingleDataViewChooserModule(
#   singleDatasetViewSpec=ADSL_viewspec
# )
# DataViewsChooserModule(
#   datasetViewsSpec=list(ADLB_viewspec, ADSL_viewspec)
# )
PlotXYModule(
datasetViewsSpec=DatasetViewsSpec(x_view=ADLB_viewspec, y_view=ADSL_viewspec)
)
)
)
shinyApp(x$ui, x$server)
shinyApp(x$ui, x$server)
shinyApp(x$ui, x$server)
?reduce
?left_join
?union
?uiOutput
source('~/choices_selected_dev/singleDatasetViewChooser.R')
devtools::load_all(".")
library(devtools)
install_github(
'NEST/random.cdisc.data',
ref = "devel",
host = 'https://github.roche.com/api/v3',
upgrade_dependencies = FALSE,
build_vignettes = TRUE
)
install_github(
'NEST/teal',
ref = "devel",
host = 'https://github.roche.com/api/v3',
upgrade_dependencies = FALSE,
build_vignettes = TRUE
)
install_github(
'NEST/teal.devel',
ref = "devel",
host = 'https://github.roche.com/api/v3',
upgrade_dependencies = FALSE,
build_vignettes = TRUE,
auth_token = readLines("~/.github_token") # because private repo
)
devtools::install_github("Roche/rtables",
upgrade_dependencies = FALSE, build_vignettes = FALSE)
devtools::install_github(
repo = "NEST/tern",
ref = "devel",
host = "https://github.roche.com/api/v3",
upgrade_dependencies = FALSE, build_vignettes = FALSE
)
devtools::install_github(
repo = "NEST/teal.modules.clinical",
ref = "devel",
host = "https://github.roche.com/api/v3",
upgrade_dependencies = FALSE, build_vignettes = FALSE,
auth_token = readLines("~/.github_token") # because private repo
)
install_github(
'NEST/teal.modules.general',
ref = "devel",
host = 'https://github.roche.com/api/v3',
upgrade_dependencies = FALSE,
build_vignettes = TRUE,
auth_token = readLines("~/.github_token") # because private repo
)
install_github(
'NEST/teal.devel',
ref = "devel",
host = 'https://github.roche.com/api/v3',
upgrade_dependencies = FALSE,
build_vignettes = TRUE,
auth_token = readLines("~/.github_token") # because private repo
)
devtools::load_all(".")
install_github(
'NEST/teal.modules.general',
ref = "master",
host = 'https://github.roche.com/api/v3',
upgrade_dependencies = FALSE,
build_vignettes = TRUE,
auth_token = readLines("~/.github_token") # because private repo
)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
?.
library(choicesselecteddev)
?"."
detach("dplyr", unload=TRUE)
detach("plyr", unload=TRUE)
unloadNamespace("plyr")
?.
?choicesselecteddev
??choicesselecteddev
install.packages("automation.utils", repos = "http://3.121.104.44:8081/repository/NEST-R/")
install.packages("sys")
install.packages("automation.utils", repos = "http://3.121.104.44:8081/repository/NEST-R/")
library(automation.utils)
build_pkgdown_website(".")
?teal.devel::white_small_well
?teal.devel::plot_with_height
?teal.devel::plot_with_height
teal.devel::plot_with_height
teal.devel::plot_height_input
#' @param label (\code{character}) Label of the Key Filtering Input inside the shiny app.
#'
#' @return A list of \code{vars} + a \link{choices_selected} outcome built by the split
#' 	selected and choices inputs.
#'
#'
#' @keywords data
#' @importFrom stats setNames
#' @export
#' @importFrom R6 R6Class
keys_filtering_spec_class <- R6Class("KeysFilteringSpec",
public = list(
vars = character(0),
cs = NULL,
initialize = function(vars, sep, choices, selected, multiple, label = "Filter") {
stopifnot(is.atomic(vars))
stopifnot(is.atomic(choices))
stopifnot(is.atomic(selected))
stopifnot(multiple || (length(selected) == 1))
split_by_sep <- function(txt) strsplit(txt, sep, fixed = TRUE)[[1]]
browser() # check [[1]] above
choices <- lapply(choices, split_by_sep)
choices %<>% setNames(choices)
stopifnot(all(vapply(choices, length, 0) == length(vars)))
selected <- lapply(selected, split_by_sep)
selected %<>% setNames(selected)
self$vars <- vars
self$cs <- choices_selected(choices, selected, multiple, label = label)
}
)
)
#' Constructor for \link{KeysFilteringSpec}
#'
#' @inheritParams KeysFilteringSpec
#' @rdname KeysFilteringSpec
#' @export
keys_filtering_spec <- function(vars, sep, choices, selected, multiple, label = "Filter") {
keys_filtering_spec_class$new(vars = vars, sep = sep,
choices = choices, selected = selected, multiple = multiple, label = label)
}
keys_filtering_spec(
vars = c("PARAMCD", "AVISIT"),
sep = " - ",
choices = c("CRP - BASELINE", "CRP - SCREENING", "ALT - BASELINE"),
selected = c("CRP - BASELINE"),
multiple=TRUE
)
choices
lapply(choices, split_by_sep)
split_by_sep <- function(txt) strsplit(txt, sep, fixed = TRUE)
split_by_sep(choices)
#' @param label (\code{character}) Label of the Key Filtering Input inside the shiny app.
#'
#' @return A list of \code{vars} + a \link{choices_selected} outcome built by the split
#' 	selected and choices inputs.
#'
#'
#' @keywords data
#' @importFrom stats setNames
#' @export
#' @importFrom R6 R6Class
keys_filtering_spec_class <- R6Class("KeysFilteringSpec",
public = list(
vars = character(0),
cs = NULL,
initialize = function(vars, sep, choices, selected, multiple, label = "Filter") {
stopifnot(is.atomic(vars))
stopifnot(is.atomic(choices))
stopifnot(is.atomic(selected))
stopifnot(multiple || (length(selected) == 1))
split_by_sep <- function(txt) strsplit(txt, sep, fixed = TRUE)
browser() # check [[1]] above
choices <- split_by_sep(choices)
stopifnot(all(vapply(choices, length, 0) == length(vars)))
selected <- split_by_sep(selected) # also a list if only a single element
self$vars <- vars
self$cs <- choices_selected(choices, selected, multiple, label = label)
}
)
)
#' Constructor for \link{KeysFilteringSpec}
#'
#' @inheritParams KeysFilteringSpec
#' @rdname KeysFilteringSpec
#' @export
keys_filtering_spec <- function(vars, sep, choices, selected, multiple, label = "Filter") {
keys_filtering_spec_class$new(vars = vars, sep = sep,
choices = choices, selected = selected, multiple = multiple, label = label)
}
keys_filtering_spec(
vars = c("PARAMCD", "AVISIT"),
sep = " - ",
choices = c("CRP - BASELINE", "CRP - SCREENING", "ALT - BASELINE"),
selected = c("CRP - BASELINE"),
multiple=TRUE
)
choices <- split_by_sep(choices)
stopifnot(all(vapply(choices, length, 0) == length(vars)))
selected <- split_by_sep(selected) # also a list if only a single element
self$vars <- vars
self$cs <- choices_selected(choices, selected, multiple, label = label)
vars
self$cs
split_by_sep(choices)
keys_filtering_spec(
vars = c("PARAMCD", "AVISIT"),
sep = " - ",
choices = c("CRP - BASELINE", "CRP - SCREENING", "ALT - BASELINE"),
selected = c("CRP - BASELINE"),
multiple=TRUE
)
split_by_sep(choices)
choices
choices <- split_by_sep(choices)
choices
choices
stopifnot(all(vapply(choices, length, 0) == length(vars)))
selected <- split_by_sep(selected) # also a list if only a single element
self$vars <- vars
self$cs <- choices_selected(choices, selected, multiple, label = label)
self$vars
self$cs
selected
names(selected)
choices_selected
# returns true if fcn evaluates to true on all elements
all_true <- function(lst, fcn) {
all(vapply(lst, fcn, TRUE))
}
#' @param label (\code{logical}) (optional) \link{DataExtractSpec} specific feature to
#'   show a different label on top of this specific \link{shiny}{selectInput}.
#'
#' @return A \code{list} of all input values. The function double checks the \code{choices}
#'   and \code{selected} inputs.
#'
#' @importFrom magrittr %<>%
#'
#'
#' @export
choices_selected <- function(choices, selected, multiple, show = FALSE, label = NULL) {
stopifnot((length(choices) >= 1) && (all_true(choices, is.atomic)))
stopifnot((length(selected) >= 1) && (all_true(selected, is.atomic)))
stopifnot(is.logical(multiple))
stopifnot(all(selected %in% choices))
browser()
if (is.null(names(choices))) {
choices %<>% setNames(choices)
}
if (is.null(names(selected))) {
selected %<>% setNames(selected)
}
out <- list(choices = choices, selected = selected, multiple = multiple, show = show, label = label)
class(out) <- "choices_selected"
return(out)
}
?selectInput
#' @param label (\code{logical}) (optional) \link{DataExtractSpec} specific feature to
#'   show a different label on top of this specific \link{shiny}{selectInput}.
#'
#' @return A \code{list} of all input values. The function double checks the \code{choices}
#'   and \code{selected} inputs.
#'
#' @importFrom magrittr %<>%
#'
#'
#' @export
choices_selected <- function(choices, selected, multiple, show = FALSE, label = NULL) {
stopifnot((length(choices) >= 1) && (all_true(choices, is.atomic)))
stopifnot((length(selected) >= 1) && (all_true(selected, is.atomic)))
stopifnot(is.logical(multiple))
stopifnot(all(selected %in% choices))
# if names is NULL, shiny will put strange labels (with quotes etc.) in the selectInput, so we set it to the values
if (is.null(names(choices))) {
choices %<>% setNames(choices)
}
if (is.null(names(selected))) {
selected %<>% setNames(selected)
}
out <- list(choices = choices, selected = selected, multiple = multiple, show = show, label = label)
class(out) <- "choices_selected"
return(out)
}
get_keysfilter_str <- function(keys_filter) {
if (is.null(keys_filter)) {
"TRUE"
} else {
keys <- keys_filter$variable_names
paste0(lapply(keys_filter$filters, function(keys_values) {
paste0(Map(function(key_name, key_value) paste0(key_name, " == '", key_value, "'"), keys, keys_values), collapse = " & ")
}), collapse = " | ")
}
}
# Returns the keysfilter_str
get_keysfilter_str(
list(variable_names=c("PARAMCD", "AVISIT"), filters=list(c("ALT", "SCREENING"), c("CRP", "BASELINE")))
)
data_extract_spec
from_source <- function(path_to_file) install.packages(path_to_file, repos = NULL, type="source")
download_dir <- "../scratch/install_packages"
for (direct in dir(download_dir)) {
from_source(file.path(download_dir, direct))
}
from_source(file.path(download_dir, "teal.modules.general"))
from_source(file.path(download_dir, "teal.modules.clinical"))
from_source(file.path(download_dir, "teal.modules.clinical"))
from_source(file.path(download_dir, "teal.modules.general"))
install.packages("DT")
from_source(file.path(download_dir, "teal.modules.general"))
runApp("tests/testthat/app.R")
devtools::load_all(".")
runApp("tests/testthat/app.R")
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
runApp("tests/testthat/app.R")
runApp("tests/testthat/app.R")
