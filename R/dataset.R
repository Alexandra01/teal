#' Data input for teal app
#'
#' Function passes datasets to teal application with option to read preprocessing code and reproducibility checking.
#' @param ASL ASL dataset
#' @param ... other datasets
#' @param code (\code{NULL} or \code{character}) preprocessing code.
#' @param check (\code{logical}) reproducibility check - whether evaluated preprocessing code gives the same objects
#'   as provided in arguments. Check is run only if flag is true and preprocessing code is not empty.
#'
#' @return a list of the input data sets
#'
#' @details This function checks if there were keys added to all data
#' 	sets that shall be analyzed inside a teal app.
#'
#' @export
#'
#' @examples
#' library(teal.devel)
#' library(random.cdisc.data)
#' asl <- radsl(N = 600, seed = 123)
#' adte <- radtte(asl, event.descr = c("STUDYID", "USUBJID", "PARAMCD"), seed = 123)
#' keys(asl) <- c("USUBJID", "STUDYID")
#' keys(adte) <- c("USUBJID", "STUDYID", "PARAMCD")
#'
#' cdisc_data(
#'   ASL = asl,
#'   ADTE = adte,
#'   code = 'asl <- radsl(N = 600, seed = 123)
#'           adte <- radtte(asl, event.descr = c("STUDYID", "USUBJID", "PARAMCD"), seed = 123)
#'           keys(asl) <- c("USUBJID", "STUDYID")
#'           keys(adte) <- c("USUBJID", "STUDYID", "PARAMCD")')
cdisc_data <- function(ASL, # nolint
                       ...,
                       code = NULL,
                       check = TRUE) {
  stopifnot(is.null(code) || (is.character(code) && length(code) == 1))
  stopifnot(is.logical(check) && length(check) == 1)

  if (is.null(code)) {
    code <- ""
  }

  if (missing(ASL)) {
    if (identical(code, "")) {
      stop("ASL and code arguments are missing.")
    } else {
      eval(parse(text = code))
      if (missing(ASL)) {
        stop("ASL is missing and cannot be generated by code.")
      }
    }
  }

  arg_values_call <- append(
    list("ASL" = substitute(ASL)),
    as.list(substitute(list(...)))[-1]
  )
  arg_values_char <- sapply(
    arg_values_call,
    function(x) {
      paste0(deparse(x), collapse = "\n")
    }
  ) %>%
    unname()

  for (i in seq_along(arg_values_call)) {
    if (is.call(arg_values_call[[i]]) && isTRUE(check) && !identical(code, "")) {
      msg <- "Automatic checking is not supported if arguments provided as calls."
      stop(msg)
    }
  }

  # eval code if argument does not exists, i.e. cdisc_data(ASL = 1, x, code = "x <- 2")
  for (i in seq_along(arg_values_call)) {
    if ((is.name(arg_values_call[[i]]) || is.call(arg_values_call[[i]])) &&
        inherits(tryCatch(eval(arg_values_call[[i]]), error = function(e) e), "error") &&
        !is.null(code)) {
      eval(parse(text = code), envir = parent.frame())
      break
    }
  }

  arg_values <- setNames(append(list(ASL), list(...)), NULL)

  arg_names <- c(
    "ASL",
    if (is.null(names(list(...)))) {
      rep("", length(arg_values) - 1)
    } else {
      names(list(...))
    }
  )

  if (any(arg_names == "")) {
    stop("All arguments passed to '...' should be named.")
  }

  # check keys
  for (i in seq_along(arg_values)) {
    if (is.null(attr(arg_values[[i]], "keys"))) {
      msg <- paste0("Cannot find 'keys' attribute in '", arg_names[i], "' argument")
      stop(msg)
    } else if (length(intersect(attr(arg_values[[i]], "keys"), attr(arg_values[[1]], "keys"))) == 0) {
      msg <- paste0("Cannot find match of '", arg_names[i], "' keys and ASL keys")
      stop(msg)
    }
  }

  res <- setNames(arg_values, arg_names)

  if (check && !identical(code, "")) {
    new_env <- new.env(parent = parent.env(.GlobalEnv))
    tryCatch({
      eval(parse(text = code), new_env)
    }, error = function(e) {
      stop(paste0("Error in checking code: ", e$message))
    })

    res_check <- vapply(
      seq_along(res),
      function(i, list, list_names, env, args_call, args_char) {
        list_obj_name <- list_names[i]
        env_obj_name <- if (is.name(args_call[[i]])) {
          args_char[i]
        } else {
          list_names[i]
        }
        tryCatch({
          identical(list[[list_obj_name]], get(env_obj_name, envir = env))
        }, error = function(e) {
          FALSE
        })
      },
      logical(1),
      list = res,
      list_names = arg_names,
      env = new_env,
      args_call = arg_values_call,
      args_char = arg_values_char
    )

    if (any(!res_check)) {
      incorrect_obj_names <- arg_names[!res_check]
      msg <- paste0(
        "Cannot reproduce object(s) ",
        paste0(paste0("'", incorrect_obj_names, "'"), collapse = ", "),
        " basing on code."
      )
      stop(msg)
    }
  }

  res <- lapply(
    seq_along(res),
    function(i) {
      structure(
        res[[i]],
        dataname = arg_names[[i]],
        source = if (identical(code, "")) {
          "# !!! Preprocessing code is empty"
        } else {
          code
        }
      )
    }
  )
  res <- setNames(res, arg_names)

  res
}
