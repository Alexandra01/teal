# This file contains Shiny modules useful for debugging and developing teal.
# We do not export the functions in this file, but show them in pkgdown. They are for
# developers only and can be accessed via `:::`.

#' Dummy module to show the filter calls generated by the right encoding panel
#'
#' The `Show R Code` functionality is not available here because
#' it is only defined in `teal.devel`.
#'
#' Please do not remove, this is useful for debugging teal without
#' dependencies and simplifies `\link[devtools]{load_all}` which otherwise fails
#' and avoids session restarts!
#'
#' @md
#' @param label `character` label of module
#' @param active_datanames `character vector` datanames shown in filter panel;
#'   can be `"all"` to mean all available datasets
#'
#' @examples
#' library(random.cdisc.data)
#' ADSL <- radsl(cached = TRUE)
#' # by testing with NA values, we will see whether the filtering really works when
#' # we add and remove filters
#' ADSL$SEX[1:150] <- NA
#' \dontrun{
#' app <- init(
#'   data = cdisc_data(
#'     cdisc_dataset(
#'       dataname = "ADSL",
#'       data = ADSL
#'     ),
#'     code = "ADSL <- radsl(cached = TRUE)"
#'   ),
#'   modules = root_modules(
#'     teal:::filter_calls_module()
#'   ),
#'   header = "Simple teal app"
#' )
#' shinyApp(app$ui, app$server)
#' }
filter_calls_module <- function(label = "Filter Calls Module", active_datanames = "all") {
  stopifnot(is_character_single(label))
  stopifnot(identical(active_datanames, "all") || is_character_vector(active_datanames))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      output$filter_calls <- renderText({
        active_datanames <- handle_active_datanames(datasets, active_datanames)
        paste(lapply(
          list_adsl_first(active_datanames),
          function(dataname) datasets$get_filter_expr(dataname)
        ), collapse = "\n\n")
      })
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("This is a dummy module."),
        p("The following filter calls are generated:"),
        verbatimTextOutput(ns("filter_calls"))
      )
    },
    filters = active_datanames
  )
}

#' Bookmarking module
#'
#' Presents a button that bookmarks the current state.
#' Note that Shiny does not bookmark uploaded files except when
#' `enableBookmarking` is set to `server`.
#' The module also prints a nice error message if bookmarking is not enabled.
#'
#' @md
#' @inheritParams filter_calls_module
bookmark_module <- function(label = "Bookmark Module") {
  stopifnot(is_character_single(label))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      observeEvent(input$bookmark, {
        if (!isTRUE(getShinyOption("bookmarkStore") %in% c("url", "server"))) {
          # isTRUE because may be NULL
          showModal(modalDialog(
            title = "Bookmarking not enabled",
            paste0(
              "Shiny bookmarking option must be enabled, its value currently is: '",
              getShinyOption("bookmarkStore"), "'."
            )
          ))
        } else {
          session$doBookmark()
        }
      })

      setBookmarkExclude("bookmark") # we do not want the window to open when it is restored
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Bookmark"),
        bookmarkButton(id = ns("bookmark"))
      )
    },
    # we show all filters so the user sees in which state the datasets will be bookmarked
    filters = "all"
  )
}

#' Module that calls `browser()` on button click
#'
#' The module presents a button that will call `browser()`.
#' This is useful as breakpoints or global variables can be set in this way.
#' When you are developing another module and find a function not working
#' as expected, without restarting the app, you can call `debug(your_fcn)` and
#' then resume execution. On the next invocation of the function, it will
#' debug it.
#'
#' @md
#' @inheritParams filter_calls_module
debug_browser_module <- function(label = "Browser Debug Module") {
  stopifnot(is_character_single(label))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      observeEvent(input$call_browser, {
        # `browser()`, this escapes the regexp that checks for browser as it is needed here as part of the module
        do.call(browser, list())
      })
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Debugging"),
        p("Once in the console, you can type `debug(your_fcn)` and resume execution. This will then debug the function the next time it is called. For example, `debugonce(session$doBookmark)`. You can also access the datasets."), #nolintr
        actionButton(ns("call_browser"), "Call browser()")
      )
    },
    filters = "all"
  )
}

#' Reset filters for the specified datasets
#'
#' The module presents a group of checkboxes to select the datasets for which to reset
#' all filters.
#'
#' @md
#' @inheritParams filter_calls_module
reset_filters_module <- function(label = "Reset Filters Module", active_datanames = "all") {
  stopifnot(is_character_single(label))
  stopifnot(identical(active_datanames, "all") || is_character_vector(active_datanames))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      observeEvent(input$reset, {
        # This works as expected because the filter panel on the right listens
        # for changes in the variable names for each dataname. (However, it does
        # not react to changes in the `filter_state` or `filter_info` of the variables.)
        lapply(
          input$datasets_to_reset,
          function(dataname) datasets$set_filter_state(dataname, varname = NULL, state = list())
        )
      })

      # reactive, handles "all" datanames
      active_datanames_r <- reactive(handle_active_datanames(datasets, active_datanames))
      # The UI may not be ready yet, i.e. updating "datasets_to_reset" won't have any effect.
      # Therefore, we ignore the first reactive cycle. The UI is ready at the next reactive cycle.
      active_datanames_r_next_cycle <- trigger_next_cycle(active_datanames_r)
      observeEvent(active_datanames_r_next_cycle(), {
        updateCheckboxGroupInput(
          session, "datasets_to_reset",
          choices = active_datanames_r(), selected = active_datanames_r()
        )
      }, ignoreNULL = FALSE)
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Reset filters"),
        checkboxGroupInput(ns("datasets_to_reset"), "Datasets to reset:"),
        actionButton(ns("reset"), "Reset")
      )
    },
    filters = active_datanames
  )
}

#' Activates the reactive expression at the next reactive flush of Shiny,
#' This is useful when the UI does not exist yet and we want to wait for it
#' Note that this triggers the first time due to the timer and from then on due to
#' the expression being evaluated.
#'
#' Note: Usage of this function should be avoided as it is a workaround.
#'
#' ```
#' # This ensures that the input is evaluated in the second reactive flash
#' # (and possibly later as well)
#' get_name <- reactiveVal("hello")
#' get_name_ui_exists <- trigger_next_cycle(get_name)
#' observeEvent(
#'   get_name_ui_exists(),
#'   updateInput(session, "initially_inexistent_input", value = get_name_ui_exists())
#' )
#' ```
#'
#' @md
#' @param expr `function or reactive`
#' @return `reactive`
# sodo1: do you like this code? I don't.
trigger_next_cycle <- function(expr) {
  stopifnot(is.function(expr))
  trigger_now <- FALSE
  reactive({
    if (!trigger_now) {
      trigger_now <<- TRUE
      invalidateLater(1) # will retrigger this and then go into else
    } else {
      expr()
    }
  })
}
