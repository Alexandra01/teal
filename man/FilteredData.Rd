% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FilteredData.R
\docType{class}
\name{FilteredData}
\alias{FilteredData}
\title{Class to encapsulate filtered datasets}
\description{
Class to encapsulate filtered datasets

Class to encapsulate filtered datasets
}
\details{
The main purpose of this class is to provide a collection of reactive datasets,
each of which can be filtered through the right filter panel of teal apps.
For each dataset, \code{get_filter_expr} returns the call to filter the dataset according
to the UI user selection.
Other classes then take care of actually merging together all the datasets.

This class is \code{ADSL}-centric in the sense that \code{ADSL} is required to apply the filters.
Every dataset, in addition to its own filter, is filtered to make sure that it only
contains keys present in \code{ADSL} (defaulting to \verb{(USUBJID, STUDYID)}).
Once the \code{ADSL} dataset is set, the filters are applied.

The datasets are filtered lazily, i.e. only when requested / needed in the Shiny app.

By the design of the class (and \code{reactiveValues}), any dataname set through \code{set_data}
cannot be removed because other code may already depend on it. As a workaround, the
underlying data can be set to \code{NULL}.

The class currently supports variables of the following types within datasets:
\itemize{
\item \code{choices}: variable of type \code{factor}, e.g. \code{ADSL$COUNTRY}
zero or more options can be selected, when the variable is a factor
\item \code{logical}: variable of type \code{logical}, e.g. \code{ADSL$TRT_FLAG}
exactly one option must be selected, \code{TRUE} or \code{FALSE}
\item \code{ranges}: variable of type \code{numeric}, e.g. \code{ADSL$AGE}
numerical range, a range within this range can be selected
Other variables cannot be filtered for.
}

Common arguments are:
\enumerate{
\item \code{filtered}: filtered dataset or not
\item \code{dataname}: one of the datasets
\item \code{varname}: one of the columns in a dataset
}
}
\examples{
library(random.cdisc.data)

ADSL <- radsl(cached = TRUE)
attr(ADSL, "keys") <- get_cdisc_keys("ADSL")
datasets <- teal:::FilteredData$new()

# to avoid using isolate(), you can provide a default isolate context by calling
# options(shiny.suppressMissingContextError = TRUE) #nolintr
# don't forget to deactivate this option at the end
# options(shiny.suppressMissingContextError = FALSE) #nolintr

isolate({
  datasets

  datasets$set_data("ADSL", ADSL)
  datasets

  datasets$datanames()
  datasets$get_data_info("ADSL", filtered = FALSE)
  # filters dataset to obtain information
  datasets$get_data_info("ADSL", filtered = TRUE)
  datasets$get_filter_info("ADSL")
  df <- datasets$get_data("ADSL", filtered = FALSE)
  # df

  datasets$get_filter_type("ADSL", "SEX")
  datasets$set_filter_state("ADSL", varname = NULL, state = list(
    AGE = list(range = c(33, 44), keep_na = FALSE),
    SEX = list(choices = c("M", "F"), keep_na = FALSE)
  ))
  datasets
  datasets$get_filter_type("ADSL", "SEX")
  datasets$get_filter_info("ADSL")[["SEX"]]$type

  # will fail because of invalid range
  # datasets$set_filter_state("ADSL", varname = NULL, list(
  #   AGE = list(range = c(3, 7), keep_na = FALSE)
  # ))
  datasets$set_filter_state("ADSL", varname = NULL, list(
    AGE = list(range = c(33, 44), keep_na = FALSE)
  ))
  datasets$set_filter_state(
    "ADSL",
    varname = "SEX",
    state = list(choices = c("M", "F"), keep_na = FALSE)
  )
  datasets$get_filter_type("ADSL", "SEX")

  datasets$get_filter_state("ADSL")

  datasets$print_filter_info("ADSL")
})
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{FilteredData$new()}}
\item \href{#method-datanames}{\code{FilteredData$datanames()}}
\item \href{#method-get_data}{\code{FilteredData$get_data()}}
\item \href{#method-set_data}{\code{FilteredData$set_data()}}
\item \href{#method-get_preproc_code}{\code{FilteredData$get_preproc_code()}}
\item \href{#method-set_preproc_code}{\code{FilteredData$set_preproc_code()}}
\item \href{#method-get_data_attr}{\code{FilteredData$get_data_attr()}}
\item \href{#method-set_data_attr}{\code{FilteredData$set_data_attr()}}
\item \href{#method-get_variable_labels}{\code{FilteredData$get_variable_labels()}}
\item \href{#method-get_keys}{\code{FilteredData$get_keys()}}
\item \href{#method-get_datalabel}{\code{FilteredData$get_datalabel()}}
\item \href{#method-get_filter_info}{\code{FilteredData$get_filter_info()}}
\item \href{#method-get_filter_type}{\code{FilteredData$get_filter_type()}}
\item \href{#method-get_filter_state}{\code{FilteredData$get_filter_state()}}
\item \href{#method-set_filter_state}{\code{FilteredData$set_filter_state()}}
\item \href{#method-get_default_filter_state}{\code{FilteredData$get_default_filter_state()}}
\item \href{#method-is_filterable}{\code{FilteredData$is_filterable()}}
\item \href{#method-get_filter_expr}{\code{FilteredData$get_filter_expr()}}
\item \href{#method-print}{\code{FilteredData$print()}}
\item \href{#method-print_filter_info}{\code{FilteredData$print_filter_info()}}
\item \href{#method-get_data_info}{\code{FilteredData$get_data_info()}}
\item \href{#method-get_bookmark_state}{\code{FilteredData$get_bookmark_state()}}
\item \href{#method-restore_state_from_bookmark}{\code{FilteredData$restore_state_from_bookmark()}}
\item \href{#method-clone}{\code{FilteredData$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$new()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Initialize a FilteredData object
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-datanames"></a>}}
\subsection{Method \code{datanames()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$datanames()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Get datanames, ADSL appears first
}

\subsection{Returns}{
\code{character} vector of datanames
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_data"></a>}}
\subsection{Method \code{get_data()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_data(dataname, filtered = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{filtered}}{\code{logical} whether to return filtered or unfiltered dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get filtered or unfiltered dataset
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_data"></a>}}
\subsection{Method \code{set_data()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_data(dataname, data)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset, without spaces}

\item{\code{data}}{\code{data.frame} data that corresponds to \code{dataname}}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Add data

Will also add the \code{md5} sum of the data.

Note: due to the nature of \code{reactiveValues()}, once a dataname
is added, it cannot be removed anymore because some code may depend
on it. You can try to achieve this by setting the data to NULL
and the observers must then know that NULL means that the dataset
was removed.

Any attributes attached to data are kept in the unfiltered data.
}

\subsection{Returns}{
\code{self} object of this class
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_preproc_code"></a>}}
\subsection{Method \code{get_preproc_code()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_preproc_code()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Get the R preprocessing code string that generates the unfiltered datasets
}

\subsection{Returns}{
\code{character} deparsed code
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_preproc_code"></a>}}
\subsection{Method \code{set_preproc_code()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_preproc_code(preproc_code)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{preproc_code}}{\code{character} preprocessing code that can be parsed to generate the
unfiltered datasets}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Set the R preprocessing code to generate the unfiltered datasets
}

\subsection{Returns}{
\code{self}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_data_attr"></a>}}
\subsection{Method \code{get_data_attr()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_data_attr(dataname, attr)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{attr}}{\code{character} attribute to get from the data attributes of the dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get data attribute for the dataset

sets and gets the data attribute on unfiltered data as it is never modified
as attributes
}

\subsection{Returns}{
value of attribute, may be NULL if it does not exist
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_data_attr"></a>}}
\subsection{Method \code{set_data_attr()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_data_attr(dataname, attr, value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{attr}}{attribute to get from the data attributes of the dataset}

\item{\code{value}}{value to set attribute to}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Set data attribute for the dataset
}

\subsection{Returns}{
\code{self} for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_variable_labels"></a>}}
\subsection{Method \code{get_variable_labels()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_variable_labels(dataname, variables = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{variables}}{(\code{character} vector) variables to get labels for;
if \code{NULL}, for all variables
Get keys for the dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get non-NA labels of variables in the data

Variables may be columns.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_keys"></a>}}
\subsection{Method \code{get_keys()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_keys(dataname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{character} keys of dataset
Get data label for the dataset

Useful to display in \verb{Show R Code}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_datalabel"></a>}}
\subsection{Method \code{get_datalabel()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_datalabel(dataname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{character} keys of dataset
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_filter_info"></a>}}
\subsection{Method \code{get_filter_info()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_filter_info(dataname, varname = NULL, all_vars = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{varname}}{\code{character} column within the dataset,
if \code{NULL}, return all (filtered) variables}

\item{\code{all_vars}}{\code{logical} (only applies if \code{varname} is NULL)
whether to include non-filtered variables; attention: only
filterable variables are included}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Return filter characteristics for a variable in a dataset
e.g. \code{range} for a \code{numeric} variable, \code{choices} for a
\code{factor} variable, \code{logical} for a \code{logical} variable.

This can be used to see how the variable must be filtered.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_filter_type"></a>}}
\subsection{Method \code{get_filter_type()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_filter_type(dataname, varname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{varname}}{\code{character} column within the dataset,
must be provided}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
See \code{get_filter_info}, only returns filter type (\code{choices}, \code{range}, \code{logical}).
}

\subsection{Returns}{
\code{character} filter type
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_filter_state"></a>}}
\subsection{Method \code{get_filter_state()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_filter_state(dataname, varname = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{varname}}{\code{character} column within the dataset;
if \code{NULL}, return all variables in a list}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Filter state for a dataset (or only a variable within it).
}

\subsection{Returns}{
\verb{character vector} filter state or list of these
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_filter_state"></a>}}
\subsection{Method \code{set_filter_state()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_filter_state(dataname, varname, state)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{varname}}{\code{character} column within the dataset;}

\item{\code{state}}{new state to set; when \code{varname} is \code{NULL}, \code{state} must be
a named list with the new filter state for each variable (variables
that are not included are unaffected)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Set filter state

The state is only updated and triggers reactive behavior when it actually
changes.
When \code{varname} is non-\code{NULL}, only the state for that variable name is changed.
Otherwise, the state is entirely set to the new state.

To remove all filters for a dataset, you can pass in \verb{varname = NULL, state = list()}.
To remove a filter variable for a dataset, pass in \verb{varname, state = NULL}.
}

\subsection{Returns}{
\code{logical} if the state was changed
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_default_filter_state"></a>}}
\subsection{Method \code{get_default_filter_state()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_default_filter_state(dataname, varname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{varname}}{\code{character} column within the dataset;
must be provided}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get the default filter state (useful for initial UI state)
This is different to NULL state which means no filter applied.
Instead, this filter is a sensible default, e.g. filter out NAs.
for numerics, full range; for factors, all choices etc.
}

\subsection{Returns}{
\verb{character vector} default filter state for this variable
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_filterable"></a>}}
\subsection{Method \code{is_filterable()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$is_filterable(dataname, varname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{varname}}{\code{character} column within the dataset;
must be provided}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Check whether the variable can be filtered, i.e. not of unknown type
}

\subsection{Returns}{
whether the variable can be filtered (type not unknown)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_filter_expr"></a>}}
\subsection{Method \code{get_filter_expr()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_filter_expr(dataname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get the call to filter the dataset according to the filter state

This can be used for the \verb{Show R Code} generation.

When the dataname is \code{ADSL}, it is simply the filtered \code{ADSL}.
Otherwise, it is the filtered dataset that only contains subjects which
are also in the filtered \code{ADSL}.

Note: The \code{dplyr::inner_join()} function in returned call will fail if the
corresponding dataset is NULL.

For the return type, note that \code{rlang::is_expression} returns \code{TRUE} on the
return type, both for base R expressions and calls (single expression,
capturing a function call).
}

\subsection{Returns}{
\code{expression} to filter dataset (taking out patients not in \code{ADSL})
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{unused arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Print method

To obtain the default printing of R6 objects with method listing,
use \code{cat(format(x))}.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print_filter_info"></a>}}
\subsection{Method \code{print_filter_info()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$print_filter_info(
  dataname,
  filtered_vars_only = FALSE,
  variables = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{filtered_vars_only}}{\code{logical} whether to only consider filtered
vars or unfiltered as well}

\item{\code{variables}}{(\code{character} vector) variables to consider; if NULL, takes all}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Prints filter characteristics of each variable for a given dataset to the
console.
}

\subsection{Returns}{
\code{NULL}, only prints
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_data_info"></a>}}
\subsection{Method \code{get_data_info()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_data_info(dataname, filtered)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{\code{character} name of the dataset}

\item{\code{filtered}}{\code{logical} whether to obtain this info for the
filtered dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get info about dataname, e.g. dimensions and
number of patients (in long datasets different from ADSL,
a patient can occur in zero or more rows)
}

\subsection{Returns}{
a list with names \verb{dim, patients}
Returns the state to be bookmarked

\code{md5} sums of \code{datasets}, \code{filter_states} and \code{preproc_code} are bookmarked,
\code{previous_filter_states} is not bookmarked.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_bookmark_state"></a>}}
\subsection{Method \code{get_bookmark_state()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_bookmark_state()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
named list
Set this object from a bookmarked state

Only sets the filter state, does not set the data, the previous filter state
and the preprocessing code.
Also checks the preprocessing code is identical if provided in the \code{state}.

Since this function is used from the end-user part, its error messages
are more verbose. We don't call the Shiny modals from here because this
class may be used outside of a Shiny app.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-restore_state_from_bookmark"></a>}}
\subsection{Method \code{restore_state_from_bookmark()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$restore_state_from_bookmark(state, check_data_md5sums = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{\code{list} containing fields \code{data_md5sums}, \code{filter_states}
and \code{preproc_code}.}

\item{\code{check_data_md5sums}}{\code{logical} whether to check that \code{md5sums} agree
for the data; may not make sense with randomly generated data per session}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
