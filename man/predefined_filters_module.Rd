% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules_debugging.R
\name{predefined_filters_module}
\alias{predefined_filters_module}
\title{Add predefined filters with a button click}
\usage{
predefined_filters_module(label = "Apply filters", filter_states)
}
\arguments{
\item{label}{\code{character} label of module}

\item{filter_states}{(\code{list}) You can define filters that show when
the app starts.
The general pattern is:
\code{list(ADSL = list(SEX = ..., AGE = ...), ADAE = ...)}.
An example is:
\code{list(ADSL = list(SEX = c("M", "F")))}.
More generally, the filters for the variable, e.g. \code{SEX} can be
specified as follows:
\code{list(SEX = list(choices = c("M", "F")))},
\code{list(SEX = list(choices = c("M", "F"), keep_na = TRUE))},
or equivalently with:
\code{list(SEX = c("M", "F"))},
\code{list(SEX = c("M", "F", NA))},
or for the default filter state (not very restrictive):
\code{list(SEX = default_filter_state())}

Instead of \code{choices} above, use the following names:
\itemize{
\item \code{numerical}: \code{range}
\item \code{factor}: \code{choices}
\item \code{logical}: \code{logical}
A general example is:
\code{list(   ADSL = list(AGE = default_filter_state(), SEX = c("M", NA)),   ADAE = list(AETOXGR = default_filter_state())   )}
Ignored if the app is restored from a bookmarked state.
}}
}
\description{
For instance, one wants to add all filters at once for a safety analysis.
}
\details{
After resetting to the predefined filters \code{filter_states}, the applied filters
will match exactly the \code{filter_states}.
There is a checkbox option to not reset those datanames that don't appear
in \code{filter_states}.
There is a checkbox option to not reset variables that are currently filtered
(but they must still appear in the \code{filter_states}, otherwise they are removed).

\strong{Note:}
The filters of all datasets are set, not just the active datanames
in the module's tab. Some datasets may be hidden from filtering, but the
filter state is still changed. However, the dataset is not immediately
recomputed, only lazily.
A drawback with the current approach is that the module computes on the full
dataset immediately after reset (which may take a lot of time) and the new
filter state is only applied in the next reactive cycle.
}
