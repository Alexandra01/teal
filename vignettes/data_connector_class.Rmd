---
title: "DataConnector Class"
author: "Dawid Kałędkowski"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DataConnector Class}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, echo=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(nomnoml)
```

### Overview
Data plays essential role in data analysis and `teal` provides several ways to include datasets into
shiny application. Normally, one develops an application in way that data is available before app 
starts. This always involves passing `cdisc_data` object into `teal::init()` function. This option
is applicable if access to data is general, so that data can be accessed by server for
multiple app users. In contrary to this, data can request some personal authorization (e.g. login and
password) which causes `teal` application to initialize in two stages: 

1. Login page
2. Loading data and start `teal` app

### Creating an app 
From developer perspective, creating an app is limited to create so called `DataConnector` object 
which is passed to `teal::init(data = <DataConnector>, ...)`. Naming convention for `DataConnector` 
is similar to previously introduced in `cdisc_data()`:

1. `<service>_cdisc_data()` alternative to `cdisc_data()` defining list of datasets and code to check.
2. `<service>_dataset()` alternative to `cdisc_dataset()` with additional service-specific arguments. 

```{r}
library(teal)
data <- rice_cdisc_data(
  rice_dataset_connector(dataname = "ADSL", path = "/path/to/ADSL"),
  rice_dataset_connector(dataname = "ADLB", path = "/path/to/ADLB")
)
```


Created `data` object is passed to `teal::init()` and after running `shinyApp` login page pops-up to
authorize access to rice API.

```{r eval=FALSE}
app <- init(
  data = data,
  modules = root_modules(
    module(
      "ADSL AGE histogram",
      server = function(input, output, session, datasets) {
        output$hist <- renderPlot({
          hist(datasets$get_dataset("ADSL", filtered = TRUE, reactive = TRUE)$AGE)
        })
      },
      ui = function(id, ...) {ns <- NS(id); plotOutput(ns('hist'))},
      filters = "ADSL"
    )
  ),
  filter = NULL,
  header = tags$h1("Sample App")
)

shinyApp(app$ui, app$server)
```

In the running application, `DataConnector` sets-up connection with `rice` and after successful 
authorization downloads datasets from provided `path`. Downloaded data are assigned to specified 
datanames in shiny environment. 
Since pre-processing is impossible for `DataConnector` before start of application, we provide 
to pre-process `ADSL` and `ADLB` after successful data loading from rice. To alter downloaded data
one should pass modification commands to `code` argument. `code` should be a single character exactly
the same as in `cdisc_data()`. `code` should refer to datanames defined by `DatasetConnector`(s). 
You don't have to pass importing step as a `code` - it will be automatically extracted 
from `DataConnector`.

```{r}
data_with_code <- rice_cdisc_data(
  rice_dataset_connector(dataname = "ADSL", path = "/path/to/ADSL"),
  rice_dataset_connector(dataname = "ADLB", path = "/path/to/ADLB"),
  code = "ADSL <- ADSL %>% mutate(new_variable = 1)
          ADLB <- ADLB %>% mutate(new_variable = 1)"
)
```

Diagram below presents steps described above. In first frame created by `rice_cdisc_data`
`DataConnector`, `ui` and `server` are passed to `teal::init()` to run app described in second
frame. `+` describes new parameters created within/by object and `/` describes object taken from
previous steps. After loading data from rice pre-processing code is applied. pre-processed data is 
converted to `cdisc_data` object and passed to shiny app alongside with specified `server` and `ui`.


```{nomnoml process diagram, echo=FALSE, fig.width=7, fig.height=4}
#spacing: 88
#arrowSize: .5

[<frame>App Setup|
   
  [DataConnector|
     + DatasetConnector(dataname, keys, labels)..*
     + code]
 [<frame>teal::init()]
 [ui]
 [server]
 
 [DataConnector] -> [<frame>teal::init()]
 [ui] -> [<frame>teal::init()]
 [server] -> [<frame>teal::init()]
 
]

[<frame>Application|
  [Auth App|
     + login
     + password
     / rice data]
  
  [Shiny App|
    / ui
    / server
    / datasets]

  [<transceiver>pre-processing|
    / rice data
    / code
  ]
  [<database>rice API| + rice data]

  [Auth App] login, pass-> [<database>rice API] 
  [<database>rice API] rice_data -> [Auth App]
  
  [Auth App] -> rice_data[pre-processing] 
  [pre-processing] -> cdisc_data[Shiny App]
]

[App Setup] -> [Application]
```


### Creating new connectors

Framework created to handle remote is managed by `DataConnector` but whole process involves four 
classes, each described in separate section. General purpose of `DataConnector` is to get extra
arguments to functions which loads data. Some arguments like passwords or logins are impossible to
include in app pre-processing, so we propose `DataConnector` which runs shiny application to get 
additional parameters.

#### 1. `CallableFunction`
Functionality of this class is to store and execute R function, with possibility to get code to
reproduce function call. In example below object of class `CallableFunction` is created which calls
`data.frame` function with provided arguments. 

```{r}
fun <- callable_function(data.frame)
fun$set_args(list(x = 1:5, y = letters[1:5]))

# check reproducible code
cat(fun$get_call())

# execte function with passed arguments
fun$run()

```

#### 2. `DatasetConnector`

Objects of this class store connection function for single dataset with additional attributes 
associated to this dataset. Object must have a `dataname` set and function to get data. In the 
example below constructing new `DatasetConnector` is wrapped by `foo_dataset` function which shows 
how we expose connectors to the developers. We use `fun` object created in previous code chunk.
This wrapper is rather toy example, but one can see the code of `rice_dataset` to see similarity and
understand how to create another wrapper.

```{r}
foo_dataset <- function(dataname, fun) {
  dc <- teal:::DatasetConnector$new()

  dc$set_dataname(dataname)
  dc$set_pull_fun(fun)
  return(dc)
}

foo <- foo_dataset("ADSL", fun) 

# get reproducible code
foo$get_call()

# execute function - get data
foo$get_dataset()
```

#### 3. `DataConnection`
This class is responsible to set connection with remote data source. `DataConnection` opens and 
closes connection. For example `rice_connection` uses following lines of code. This class doesn't 
load data. Class is used before and after data loading. Code for opening and closing connection will 
be added to R code generated by teal apps.

```{r}
open_fun <- callable_function(rice::rice_session_open)
close_fun <- callable_function(rice::rice_session_close)
close_fun$set_args(list(message = FALSE))

x <- teal:::DataConnection$new() # nolint
x$set_open_fun(open_fun)
x$set_close_fun(close_fun)
```

#### 4. `DataConnector`

This class spins previously described elements and creates shiny application to obtain additional
arguments. 
Once again `DatasetConnector`(s) and `DatasetConnection` are created using `rcd_dataset_connector` and 
`rcd_connection` respectively.

```{r}
library(random.cdisc.data)
connectors <- list(
  rcd_dataset_connector("ADSL", radsl, cached = TRUE),
  rcd_dataset_connector("ADLB", radlb, cached = TRUE)
)
con <- teal:::rcd_connection()

```

In code chunk below `shiny` `ui` element is created which is going to be displayed on the first app 
screen. 
**Important:** ui should contain submit button which confirms that choice have been made. 
```{r}
ui <- function(id) {
  ns <- NS(id)
  tagList(
    numericInput(ns("seed"), "Choose seed", min = 1, max = 1000, value = 1),
    actionButton(ns("submit"), "Submit")
  )
}
```

`DatasetConnector`(s), `DataConnection` and ui element are put into `DataConnector`. 
**Important:** `set_server_helper` handles chosen inputs in app. `DataConnector` checks if user 
confirmed inputs by listening ui element linked by `submit_id = "submit"`. After submitting
inputs are saved in class object.
One can use helper method `x$launch` which opens shiny application where one can choose `seed` for 
random data. 
```{r}
x <- teal:::DataConnector$new()

x$set_connection(con)
x$set_connectors(connectors)
x$set_code(code = "ADSL$x <- 1")
x$set_ui(ui)
x$set_server_helper(
  submit_id = "submit",
  fun_args_fixed = list(seed = quote(input$seed))
)
```

```{r eval=FALSE}
x$launch()
```

```{r}
cdisc_data <- x$get_cdisc_data()
cat(attr(cdisc_data, "code"))
```

To confirm that shiny input has been saved, one can check reproducible code to see that 
`seed` matches app user choice.

```{r}

```



#### UML diagram

```{nomnoml class diagram, echo=FALSE, fig.width=7, fig.height=4}
  #spacing: 88
  #arrowSize: .5
  [CallableFunction||
     + init(Function fun)
     + get_call()
     + set_args(args)
     + set_arg_value(name, value)
     + run()|
     - function fun_name
     - list args 
     - character call]

  [DatasetConnector||
     + get_call()
     + get_dataset()
     + get_dataname()
     + set/get_dataname(dataname)
     + set/get_pull_fun(CallableFunction fun)
     + set/get_pull_fun_args(args)
     + set/get_pull_arg_value(name, value)|
     - list data
     - character dataname
     - list keys
     - character labels
     - character path
     - CallableFunction pull_fun
     ]
  
  [DataConnection||
    + set_open_fun(CallableFunction)
    + set_open_args(args)
    + set_close_fun(CallableFunction)
    + set_close_args(args)|
    - CallableFunction open_fun
    - CallableFunction close_fun
  ]
        
  [DataConnector||
    + launch()
    + get_cdisc_data()
    + get/set_ui(ui)
    + get/set_server(server)
    + get/set_connection(DataConnection)
    + get/set_connectors(DatasetConnector)
    + get/set_code(code)|
    - server
    - ui
    - cdisc_data
    - DataConnection connection 0..1
    - DatasetConnectors connectors 1..
    - character code
    - logical check
    - list data
  ]


  [CallableFunction] -> [DatasetConnector]
  [CallableFunction] -> [DataConnection]

  [DataConnection] -> [DataConnector]
  [DatasetConnector] -> [DataConnector]
```
